const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const jwt = require('jsonwebtoken');
const User = require('./models/User'); // ‚úÖ IMPORTE O MODELO DE USU√ÅRIO

require('dotenv').config();

const app = express();

// ‚úÖ Middlewares
app.use(cors());
app.use(express.json());

// ‚úÖ CONFIGURA√á√ïES
const MONGODB_URI = process.env.MONGODB_URI;
const JWT_SECRET = process.env.JWT_SECRET || 'ipb_jwt_secret_2024';
const QUICK_TOKEN_SECRET = process.env.QUICK_TOKEN_SECRET || 'ipb_quick_token_2024';

let isDBConnected = false;

const connectDB = async () => {
  try {
    console.log('üîó Conectando ao MongoDB...');
    
    await mongoose.connect(MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      serverSelectionTimeoutMS: 30000,
    });
    
    isDBConnected = true;
    console.log('‚úÖ MongoDB CONECTADO!');
    
    // ‚úÖ CRIA USU√ÅRIOS INICIAIS
    await createInitialUsers();
    
  } catch (error) {
    console.error('‚ùå Erro MongoDB:', error.message);
    isDBConnected = false;
    setTimeout(connectDB, 10000);
  }
};

// ‚úÖ MIDDLEWARE DE AUTENTICA√á√ÉO JWT
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Token de acesso requerido' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Token inv√°lido ou expirado' });
    }
    req.user = user;
    next();
  });
};

// ‚úÖ MIDDLEWARE PARA VERIFICAR PERMISS√ïES
const requireAuth = (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({ error: 'Autentica√ß√£o requerida' });
  }
  next();
};

const requireAdminOrEditor = (req, res, next) => {
  if (!req.user || (req.user.role !== 'admin' && req.user.role !== 'editor')) {
    return res.status(403).json({ error: 'Acesso negado. Apenas administradores e editores.' });
  }
  next();
};

const requireAdmin = (req, res, next) => {
  if (!req.user || req.user.role !== 'admin') {
    return res.status(403).json({ error: 'Acesso negado. Apenas administradores.' });
  }
  next();
};

// ‚úÖ FUN√á√ÉO PARA CRIAR USU√ÅRIOS INICIAIS
const createInitialUsers = async () => {
  try {
    const initialUsers = [
      { name: 'Almir', username: 'almir', password: '1515', role: 'admin' },
      { name: 'Franklin', username: 'franklin', password: '1212', role: 'admin' },
      { name: 'Marcio', username: 'marcio', password: '1010', role: 'admin' },
      { name: 'Milena', username: 'milena', password: '1111', role: 'admin' },
      { name: 'Sabrina', username: 'sabrina', password: '2020', role: 'admin' },
      // ‚úÖ USU√ÅRIO VIEWER PARA TESTE
      { name: 'Visitante', username: 'visitante', password: '0000', role: 'viewer' }
    ];

    for (const userData of initialUsers) {
      const existingUser = await User.findOne({ username: userData.username });
      
      if (!existingUser) {
        const user = new User(userData);
        await user.save();
        console.log(`‚úÖ Usu√°rio criado: ${userData.name} (${userData.role})`);
      } else {
        console.log(`‚ö†Ô∏è Usu√°rio j√° existe: ${userData.name}`);
      }
    }
    
    console.log('üéâ Sistema de usu√°rios pronto!');
    
  } catch (error) {
    console.error('‚ùå Erro ao criar usu√°rios:', error);
  }
};

// ‚úÖ ROTAS DE AUTENTICA√á√ÉO

// LOGIN COM CREDENCIAIS
app.post('/api/auth/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    const cleanUsername = username?.trim().toLowerCase() || '';
    const cleanPassword = password?.trim() || '';
    
    console.log('üîê Tentativa de login:', cleanUsername);
    
    // Buscar usu√°rio
    const user = await User.findOne({ 
      username: cleanUsername, 
      isActive: true 
    });
    
    if (!user) {
      console.warn('‚ùå Usu√°rio n√£o encontrado:', cleanUsername);
      return res.status(401).json({ 
        success: false, 
        error: 'Credenciais inv√°lidas' 
      });
    }
    
    // Verificar senha
    const isPasswordValid = await user.comparePassword(cleanPassword);
    
    if (!isPasswordValid) {
      console.warn('‚ùå Senha inv√°lida para:', cleanUsername);
      return res.status(401).json({ 
        success: false, 
        error: 'Credenciais inv√°lidas' 
      });
    }
    
    // Atualizar √∫ltimo login
    user.lastLogin = new Date();
    await user.save();
    
    // Gerar JWT Token
    const token = jwt.sign(
      { 
        userId: user._id, 
        username: user.username, 
        name: user.name, 
        role: user.role 
      },
      JWT_SECRET,
      { expiresIn: '30d' } // Token expira em 30 dias
    );
    
    console.log(`‚úÖ Login bem-sucedido: ${user.name} (${user.role})`);
    
    res.json({
      success: true,
      message: 'Login realizado com sucesso!',
      user: user.toPublicJSON(),
      token: token
    });
    
  } catch (error) {
    console.error('üí• Erro no login:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Erro interno do servidor' 
    });
  }
});

// ‚úÖ VERIFICAR TOKEN (para login autom√°tico)
app.get('/api/auth/verify', authenticateToken, async (req, res) => {
  try {
    // Buscar usu√°rio atualizado
    const user = await User.findById(req.user.userId);
    
    if (!user || !user.isActive) {
      return res.status(401).json({ 
        success: false, 
        error: 'Usu√°rio n√£o encontrado ou inativo' 
      });
    }
    
    res.json({
      success: true,
      user: user.toPublicJSON()
    });
    
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: 'Erro ao verificar token' 
    });
  }
});

// ‚úÖ ROTAS DE USU√ÅRIOS (APENAS ADMINS)

// LISTAR TODOS OS USU√ÅRIOS
app.get('/api/users', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const users = await User.find({}, '-password');
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// CRIAR NOVO USU√ÅRIO
app.post('/api/users', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { name, username, password, role = 'viewer' } = req.body;
    
    if (!name || !username || !password) {
      return res.status(400).json({ error: 'Nome, usu√°rio e senha s√£o obrigat√≥rios' });
    }
    
    const existingUser = await User.findOne({ username: username.toLowerCase() });
    if (existingUser) {
      return res.status(400).json({ error: 'Usu√°rio j√° existe' });
    }
    
    const newUser = new User({
      name,
      username: username.toLowerCase(),
      password, // A senha ser√° hasheada automaticamente pelo middleware
      role
    });
    
    const savedUser = await newUser.save();
    
    res.status(201).json({
      success: true,
      message: 'Usu√°rio criado com sucesso',
      user: savedUser.toPublicJSON()
    });
    
  } catch (error) {
    console.error('‚ùå Erro ao criar usu√°rio:', error);
    res.status(400).json({ error: error.message });
  }
});

// ATUALIZAR USU√ÅRIO
app.put('/api/users/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, role, isActive, preferences } = req.body;
    
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: 'ID inv√°lido' });
    }
    
    const updatedUser = await User.findByIdAndUpdate(
      id,
      { name, role, isActive, preferences },
      { new: true, select: '-password' }
    );
    
    if (!updatedUser) {
      return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
    }
    
    res.json({
      success: true,
      message: 'Usu√°rio atualizado com sucesso',
      user: updatedUser
    });
    
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// ‚úÖ ROTAS DE POSTS COM CONTROLE DE ACESSO

// GET POSTS (P√öBLICO - TODOS PODEM VER)
app.get('/api/posts', async (req, res) => {
  try {
    const { category } = req.query;
    
    if (isDBConnected && mongoose.connection.readyState === 1) {
      const filter = { isActive: true };
      if (category && category !== 'all') filter.category = category;
      const posts = await Post.find(filter).sort({ date: -1 });
      res.json(posts);
    } else {
      // Fallback
      res.json([{
        _id: 'fallback-1',
        title: 'Sistema IPB Online!',
        text: 'Backend funcionando perfeitamente.',
        category: category || 'Eventos',
        date: new Date().toISOString(),
        images: [],
        author: 'Sistema'
      }]);
    }
  } catch (error) {
    console.error('‚ùå Erro em /api/posts:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// ‚úÖ CRIA√á√ÉO/EDI√á√ÉO/EXCLUS√ÉO APENAS PARA ADMINS E EDITORS
app.post('/api/posts', authenticateToken, requireAdminOrEditor, async (req, res) => {
  try {
    const { title, text, category, date, images = [] } = req.body;
    
    if (!title || !text || !category || !date) {
      return res.status(400).json({ error: 'Todos os campos s√£o obrigat√≥rios' });
    }
    
    const newPost = new Post({ 
      title, 
      text, 
      category, 
      date: new Date(date), 
      images,
      author: req.user.name // ‚úÖ USA O NOME DO USU√ÅRIO LOGADO
    });
    
    const savedPost = await newPost.save();
    res.status(201).json(savedPost);
    
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.put('/api/posts/:id', authenticateToken, requireAdminOrEditor, async (req, res) => {
  try {
    const { id } = req.params;
    const { title, text, category, date, images } = req.body;
    
    if (!title || !text || !category || !date) {
      return res.status(400).json({ error: 'Todos os campos s√£o obrigat√≥rios' });
    }
    
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: 'ID inv√°lido' });
    }
    
    const updatedPost = await Post.findByIdAndUpdate(
      id, 
      { title, text, category, date: new Date(date), images },
      { new: true, runValidators: true }
    );
    
    if (!updatedPost) {
      return res.status(404).json({ error: 'Post n√£o encontrado' });
    }
    
    res.json(updatedPost);
    
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.delete('/api/posts/:id', authenticateToken, requireAdminOrEditor, async (req, res) => {
  try {
    const { id } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: 'ID inv√°lido' });
    }
    
    const deletedPost = await Post.findByIdAndUpdate(
      id, 
      { isActive: false },
      { new: true }
    );
    
    if (!deletedPost) {
      return res.status(404).json({ error: 'Post n√£o encontrado' });
    }
    
    res.json({ message: 'Post deletado com sucesso', post: deletedPost });
    
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ‚úÖ ROTAS P√öBLICAS
app.get('/api/health', (req, res) => {
  const status = mongoose.connection.readyState;
  const states = { 0: 'disconnected', 1: 'connected', 2: 'connecting', 3: 'disconnecting' };
  
  res.json({ 
    message: 'üöÄ API IPB com Sistema de Usu√°rios!',
    database: states[status],
    readyState: status,
    connected: isDBConnected,
    timestamp: new Date().toISOString()
  });
});

app.get('/', (req, res) => {
  res.json({ 
    message: '‚úÖ Backend IPB - Sistema Completo!',
    features: [
      'Sistema de usu√°rios com roles (admin, editor, viewer)',
      'Autentica√ß√£o JWT',
      'Login autom√°tico com token',
      'Controle de acesso granular'
    ],
    timestamp: new Date().toISOString()
  });
});

// ‚úÖ INICIAR CONEX√ÉO
connectDB();

const PORT = process.env.PORT || 10000;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`üéØ Servidor rodando na porta: ${PORT}`);
  console.log(`üîê Sistema de autentica√ß√£o JWT ativo`);
  console.log(`üë• Usu√°rios: Almir(1515), Franklin(1212), Marcio(1010), Milena(1111), Sabrina(2020)`);
});

module.exports = app;